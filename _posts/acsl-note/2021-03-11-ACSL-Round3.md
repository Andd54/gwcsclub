---
layout: post
title: ACSL Round 3
tags: ACSL
time: 2020
Author: Mark
---

<div class="error">
这个页面尚未完工
</div>

## 1. 布尔代数 Boolean Algebra

在上一轮中，我们在 Bit String Flickering 中已经接触过二进制字符串的操作并了解了 AND,OR,XOR,NOT 这些基本的逻辑运算符。这次我们不会对包含很多位的二进制字符串做操作，而是对单个布尔值做逻辑运算操作。

### 1.1 布尔代数运算符

| 运算符       | 含义        |
| ------------ | ----------- |
| $A + B$      | $A$ OR $B$  |
| $A * B$      | $A$ AND $B$ |
| $A \oplus B$ | $A$ XOR $B$ |
| $\bar{A}$    | NOT $A$     |

<p class="info">
    在一些情境下，我们回省略两个布尔变量之间的 $*$ 号，例如直接将 $A * B$ 写为 $AB$
</p>



### 1.2 布尔代数化简求值

那么在只有一位的时候我们如何对表达式进行化简与求值呢？这就要求我们要把布尔代数表达式划分成一个个小的表达式分别进行求值和推断了。

#### 1.2.1 使用 AND, OR 的特性求值

如果我们有两个未知的布尔值变量 $A$ ，虽然我们不能确定他的值，但是我们依然可以对以下这些式子进行化简求值……

| 布尔代数表达式 | 求值结果 | 解释                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| $A + 1$        | 1        | 虽然不知道 $A$ 是 0 还是 1，任何布尔值与1进行 OR 操作的结果都是 1，所以这个式子的值是常量 1 |
| $A + \bar{A}$  | 1        | 虽然我们不知道 $A$ 的值，但是 $A$ 和 $\bar{A}$  中至少有一个是 1，另一个是 0，所以两个值 OR 的结果是 1 |
| $A * 0$        | 0        | 无论 $A$ 是什么，与 0 做 AND 操作的结果只能是 0              |
| $A * \bar{A}$  | 0        | 无论 $A$ 是什么，$A$ 与 $\bar{A}$ 中一定有一个是 0，0 与任何值进行 AND 计算结果都是 0 |

#### 1.2.2  布尔运算优先级

和普通的四则运算一样，布尔运算也是有优先级的，布尔运算的优先级遵从下面这个顺序

```
NOT > AND > XOR > OR
```

用布尔运算的符号表示，则有

$$
\bar{} > * > \oplus > +
$$

#### 1.2.3 布尔运算法则

对于普通的四则运算，我们有交换律，结合律和分配律等运算法则。对于布尔运算，我们也有类似的运算法则

**分配律**

$$
A * (B + C) \leftrightarrow AB + AC
$$

**结合律**

$$
A*B*C \leftrightarrow A * (B*C)
$$

**交换律**

$$
A + B \leftrightarrow B + A\\
A * B \leftrightarrow B * A
$$

除此之外，还有一些特殊的运算法则是四则运算中没有的，例如

**DeMorgan's Law**

$$
\overline{A + B} \leftrightarrow \overline{A} * \overline{B}
$$

$$
\overline{A * B} \leftrightarrow \overline{A} + \overline{B}
$$

**异或化简法则（异或的定义）**

$$
A \oplus B \leftrightarrow A\overline{B} + \overline{A}B
$$

$$
\overline{A \oplus B} \leftrightarrow AB + \overline{A}*\overline{B}
$$

### 1.3 例子

在实际运算中，1.2.3 的运算法则要和 1.2.1 中的求值结合起来使用，只有这样才能将布尔代数表达式化简到最简形式。下面我们用两个例子来说明如何做 ACSL 中布尔代数的相关题目

**例1  Simplify the following expression   $A(A + BC) + B(B + AC)$**

Solution

$$
\begin{aligned}
&= A + ABC + B + BAC \\
&= A + ABC + B\\
&= A + B(AC + 1)\\
&= A + B
\end{aligned}
$$

这里我们用到了一个技巧 - 一个单独的变量 $A$ 可以看作 $A * 1$ 的结果，类似的，在一些情况下你也可以把 $A$ 看作 $A + 0$  的结果。

**例2   How many pairs / List all the pairs of ABC that make the following expression FALSE**

$$
\overline{AB} + A\overline{B + C}
$$

遇到这种题的时候我们先将给定的表达式进行化简

$$
\begin{aligned}
&= \bar{A} + \bar{B} + A * (\bar{B} * \bar{C}) \\
&= \bar{A} + \bar{B} * (1 + A\bar{C})\\
&= \bar{A} + \bar{B}
\end{aligned}
$$

在进行完化简后我们再将所有的 ABC 取值列一张表格进行求值

| $A$   | $B$   | $C$   | $\bar{A} + \bar{B}$ |
| ----- | ----- | ----- | ------------------- |
| 0     | 0     | 1     | 1                   |
| 0     | 0     | 0     | 1                   |
| 0     | 1     | 1     | 1                   |
| 0     | 1     | 0     | 1                   |
| 1     | 0     | 1     | 1                   |
| 1     | 0     | 0     | 1                   |
| **1** | **1** | **1** | **0**               |
| **1** | **1** | **0** | **0**               |

列出这张表后，我们可以看到当 $A, B, C$ 等于 $(1, 1, 1)$ 和 $(1, 1, 0)$ 时，$\bar{A} + \bar{B}$ 的值时 FALSE。

###  1.4 练习

## 2 数据结构 Data Structure

对一个程序来说，算法和数据结构必不可少。ACSL中考察的数据结构主要有以下几种：

* Queue 队列
* Stack 堆栈
* Binary Search Tree 二分查找树
* Priority Queue 优先队列

### 2.1 队列与堆栈 Queue & Stack

队列指遵循 FIFO (First in First Out) 的规则。先进入队列的对象会先被取出来。堆栈遵循 FILO （First in Last Out）的规则，先进入堆栈的对象会后被取出来。 队列和堆栈有的时候也被称为 FIFO Stack 和 FILO Stack。

常见的 Queue / Stack 操作有以下几种：

* $PUSH(N)$ 将 $N$ 放入 数据结构中
* $POP()$ 从数据结构中取出对象
* $REVERSE()$ 将现在数据结构中的对象顺序反转
* $SWITCH()$ 将当前数据结构切换为 Stack / Queue

#### 2.1.1 PUSH(N) & POP(X) 方法

例1：Stack

$$
PUSH(A), PUSH(B), POP(X), PUSH(C)
$$

What will be the next element pop out of stack? 

解：

![6effc8f594043b89ed1d30d0fa4ab6d](https://gitee.com/MarkYutianChen/mark-markdown-imagebed/raw/master/20210317072407.jpg)

下一个被 POP 出 Stack 的是 $B$。

#### 2.1.2 REVERSE() 方法

反转当前数据结构内所有的对象顺序

例2：Queue
$$
PUSH(A), PUSH(N), REVERSE(), POP(X), PUSH(B)
$$
What will be the next element pop out of queue?

解：

![b173946ab222b27739c027b54946d78](https://gitee.com/MarkYutianChen/mark-markdown-imagebed/raw/master/20210317073918.jpg)

下一个被 POP 出 Queue 的是 $A$

#### 2.1.3 SWITCH() 方法

如果现在数据结构是 Stack，执行完 SWITCH() 后数据结构变为 Queue，内部对象顺序不变，反之亦然。

### 2.2 二分查找树 Binary Search Tree

二分查找树是一种数据结构，也是一种树（无环图）。

#### 2.2.1 图论：树的术语

1. **根节点 (Root Node)** - 最顶端的节点
2. **父节点 (Parent Node)** 下面直接相连的节点叫做**子节点 (Child Node)**
3. 有同一个父节点的节点称为**兄弟节点（Sibling Node）**
4. 每个分支最底部的节点被称为**叶子节点 (Leaf Node)**，叶节点没有子节点

<img src="https://gitee.com/MarkYutianChen/mark-markdown-imagebed/raw/master/20210317075216.jpg" alt="2e6ee6f3e87fd2673d76c8c4a8b6534" style="zoom:30%; display: block; margin: 0 auto" />

#### 2.2.2 二分查找树的性质

二分查找树的每个节点有三个属性 - 节点的值 (key) ，指向左侧子节点的指针 (left child pointer)，指向右侧子节点的指针 (right child pointer)

在一个**排好序的二分查找树中**，每个节点的 key 比左子节点的 key 大（如果存在左子节点），比右子节点的 key 小（如果存在右子节点）

<mark>重复的 key 小于原有的 key。也就是说如果 key "A" 在BST中出现了两次，那么第二次的A一定在第一次出现的A的节点的左侧</mark>

#### 2.2.3 二分查找树的属性

| 属性                 | 解释                                            |
| -------------------- | ----------------------------------------------- |
| Depth                | 距离根节点最远的叶子节点的高度（根节点高度为0） |
| Internal Path Length | 所有节点的深度之和                              |
| External Path Length | 所有**可加入**二分查找树的位置的高度之和        |

例1：

<img src="https://gitee.com/MarkYutianChen/mark-markdown-imagebed/raw/master/20210317081043.jpg" alt="816153b6120c4f193d13c317fac68df" style="zoom:30%; display:block; margin: 0 auto" />

$$
\text{Depth} = 3
$$

$$
\text{Internal Path Legth} = 0 + 1\times 2 + 2 \times 3 + 3\times 2 = 0 + 2 + 6 + 6 = 14
$$

$$
\text{External Path Length} = 2\times 1 + 3\times 4 + 4\times 4 = 2 + 12 + 16 = 30
$$

#### 2.3.4 二分查找树的遍历输出 (Traverse)

有三种方法遍历一个二分查找树 - Inorder, Preorder, Postorder

* Inorder - 先描述树的左子树，然后描述根节点，最后描述右边的子树
* Preorder - 先描述树的根节点，然后描述树的左，右节点
* Postorder - 先描述左子树，然后描述右子树，最后描述根节点

拿这颗树作为例子：

> <img src="https://gitee.com/MarkYutianChen/mark-markdown-imagebed/raw/master/20210317075216.jpg" alt="2e6ee6f3e87fd2673d76c8c4a8b6534" style="zoom:20%; display: block; margin: 0 auto" />
>
> * Inorder 描述：C,B,D,A,E
> * Preorder 描述：A,B,C,D,E
> * Postorder 描述：C,D,B,E,A

