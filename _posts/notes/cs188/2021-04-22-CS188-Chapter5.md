---
layout: post
title: CS188 Chapter 5 Adversarial Search
Author: Mark
tags: Notes CS188
---

### 1. Games

This chapter describes the **Competitive Environments** for agents, where their goals are conflict. Such problem is called the **adversarial search** problems - often known as **games**.

In the field of AI, the most common games are a special kind of game - the **Deterministic, Turn-taking, Two-player, Zero-sum games** of **Perfect Information** (such as chess).

Games are interesting since they are hard to solve using direct search - the branching factor of game is too large that it is impossible to search through all possible states. Also, games penalize inefficiency severely so the program should be as fast as possible.

**Pruning** （剪枝） allows us to ignore portions of search tree that make no difference to the final choice. Heuristic **Evaluation Functions** allow us to approximate the true utility of a state without doing a complete search.

Suppose there are two agents - "MAX" and "MIN". In a game, "MAX" move first and they take turn to move until the game is over. The winner get points and loser get penalty.

#### 1.1 Formally Defined Game

A game can be formally defined with these elements

| Element            | Explanation                                                  |
| ------------------ | ------------------------------------------------------------ |
| $S_0$              | The Initial State of game (the setup of game)                |
| $Player(s)$        | Defines which player has a move in the current state $s$     |
| $Actions(s)$       | Returns a list of legal actions in a state $s$               |
| $Result(s, a)$     | The *state transition model*, which defines the result of an action $a$ |
| $Terminal-Test(s)$ | Returns `true` if the game is over, `false` otherwise        |
| $Utility(s, p)$    | A utility function defines the numeric value for a game that ends in terminal state $s$ for player $p$ |