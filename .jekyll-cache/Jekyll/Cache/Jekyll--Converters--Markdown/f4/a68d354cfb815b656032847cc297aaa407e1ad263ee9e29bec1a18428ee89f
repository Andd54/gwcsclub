I"#<h1 id="usaco-2017-feb-gold-analysis">USACO 2017 Feb Gold Analysis</h1>

<p>[toc]</p>

<h2 id="problem-1-why-did-the-cow-cross-the-road">Problem 1. Why did the Cow Cross the Road</h2>

<h3 id="problem-description">Problem Description</h3>

<p>Bessie the cow wants to move from the upper-left corner of field to the bottom-right corner of field. Each time it goes from one grid to the other, <em>$T$ unit</em> of time will be consumed. Each time Bessie pass through 3 grids, she will stop at the grid and begin eating. The time of eating in each grid is different and will be provided in the input.</p>

<p>$3 \leq N \leq 100, 0\leq T\leq 1\times 10^6$</p>

<h3 id="proposed-solution">Proposed Solution</h3>

<p>The first thought on this problem is to solve by using <strong>Unified Cost Search (UCS)</strong>. By maintain a fringe of Priority Queue that is sorted according to the time consumes to arrive at a specific position, it is promised that the first state we have met that arrived at the destination will be the state that consumes LEAST time to arrive at the destination.</p>

<p>Therefore, we can represent a State $S$ in this form</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">State</span> <span class="n">newState</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="nc">Time</span><span class="o">,</span> <span class="n">num</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
</code></pre></div></div>

<p>And accordingly, the state transition function will be somehow like this</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="nf">StateTransition</span><span class="o">(</span><span class="nc">State</span> <span class="n">currState</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">currTime</span> <span class="o">=</span> <span class="n">currState</span><span class="o">.</span><span class="na">getTime</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">currState</span><span class="o">.</span><span class="na">getNum</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">currX</span> <span class="o">=</span> <span class="n">currState</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">currY</span> <span class="o">=</span> <span class="n">currState</span><span class="o">.</span><span class="na">gety</span><span class="o">();</span>
    
    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">nextStates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    <span class="nc">Move</span><span class="o">[]</span> <span class="n">validMove</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getValidMove</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Move</span> <span class="n">move</span> <span class="o">:</span> <span class="n">validMove</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">nextTime</span> <span class="o">=</span> <span class="n">currTime</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">change</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="na">getChange</span><span class="o">();</span>
        <span class="n">nextX</span> <span class="o">=</span> <span class="n">currX</span> <span class="o">+</span> <span class="n">change</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">nextY</span> <span class="o">=</span> <span class="n">currY</span> <span class="o">+</span> <span class="n">change</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span> <span class="n">nextTime</span> <span class="o">+=</span> <span class="k">this</span><span class="o">.</span><span class="na">Time</span><span class="o">[</span><span class="n">nextX</span><span class="o">][</span><span class="n">nextY</span><span class="o">]</span> <span class="o">}</span>
        <span class="n">nextStates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">nextTime</span><span class="o">,</span> <span class="n">num</span><span class="o">,</span> <span class="n">nextX</span><span class="o">,</span> <span class="n">nextY</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>

<p>Since the time that UCS iterate is not bounded explicitly and there does not has an explicit relationship between data scale and number of iteration, it is hard to calculate accurate time complexity. Below, we will try to estimate an upper bound.</p>

<p>First, there are $N^2$ vertexes in the graph, suppose each node is explored for $N$ time (which is an over-estimation), the time complexity of travel through the graph using UCS is $O(N^3)$. Since each state is push and pop from a priority queue that is maintained using binary heap, the time complexity of push &amp; pop one state is $O(\log n)$. The overall time complexity should be less than $O(N^3 \log(n))$.</p>

<p>Since $3\leq N\leq 100$, the time complexity of $O(N^3 \log{n})$ is acceptable.</p>
:ET